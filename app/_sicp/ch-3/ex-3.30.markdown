---
chapterName: "Modularity, Objects, and State"
chapter: 3
solution: "3.30"
order: "030"
date: 2018-02-12 
---

Note that from this exercise onwards, I shifted to MIT-scheme. There were two reasons behind it - (i) I recently started learning emacs and want to use it here (ii) Sometimes there are few cases which were not exactly same in Dr Racket sicp language package as expected - eg: mcons.

Assuming that list contains bits ordered as A1, A2 ... i.e. first element of list contains the first bit and so on.

Note while adding last elements An and Bn, we need to send `c-in = 0` in the adder.

Thus addition process starts from the last element/bit and the output carry is then fed as `c-in` in full adder while adding penultimate element/bit and then the carry generated is fed into full adder for adding last second bits and so on till we reach the first element. 

And when we add the first element the carry generated by this full-adder becomes the final carry C from adding n bits.

{% highlight scheme linenos %}
(define (ripple-carry-adder As Bs Ss C)
  (let ((carry (make-wire)))
    (if (null? As)
		(set-signal! C 0)
	    (begin
		 (ripple-carry-adder (cdr As) (cdr Bs) (cdr Ss) carry)
		 (full-adder (car As) (car Bs) carry (car Ss) C)))))
{% endhighlight %}

Note that the mutability has caused to write the expressions in a certain order - we need the carry set/assigned by `ripple-carry-adder` before `calling full-adder`.

We can not test this code at this point in the book because agenda data-structure is not yet available. Later after this was introduced, I completed the code and putting the complete code here:

{% highlight scheme linenos %}

;; ripple n-bit adder
(define (ripple-carry-adder As Bs Ss C)
  (let ((carry (make-wire)))
    (if (null? As)
		(set-signal! C 0)
	    (begin
		 (ripple-carry-adder (cdr As) (cdr Bs) (cdr Ss) carry)
		 (full-adder (car As) (car Bs) carry (car Ss) C)))))

;; half and full adder

(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))

(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))

;; gates implementation

(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))

(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
(define (logical-and a b)
  (cond ((and (= a 0) (= b 0)) 0)
		((and (= a 1) (= b 0)) 0)
		((and (= a 0) (= b 1)) 0)
		((and (= a 1) (= b 1)) 1)
		(else (error "Invalid signal" a b))))

(define (or-gate a1 a2 output)
  (define (or-action-procedure)
	(let ((new-value
		   (logical-or (get-signal a1) (get-signal a2))))
	  (after-delay or-gate-delay
				   (lambda ()
					 (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
(define (logical-or a b)
  (cond ((and (= a 0) (= b 0)) 0)
		((and (= a 1) (= b 0)) 1)
		((and (= a 0) (= b 1)) 1)
		((and (= a 1) (= b 1)) 1)
		(else (error "Invalid signal" a b))))
;; wire implementation

(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))

(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))

(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))

;; Agenda implementation

(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))

(define (make-agenda) (list 0))
(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda) (car (segments agenda)))
(define (rest-segments agenda) (cdr (segments agenda)))

(define (empty-agenda? agenda)
  (null? (segments agenda)))

(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))

(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))

(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))

(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))

(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))

(define (probe name wire)
  (add-action! wire
               (lambda ()        
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))

(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)

;; Queue implementation
(define (make-queue)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (set-front-ptr! item) (set! front-ptr item))
    (define (set-rear-ptr! item) (set! rear-ptr item))

    (define (empty-queue?) (null? front-ptr))
    
    (define (front-queue)
      (if (empty-queue?)
          (error "FRONT called with an empty queue")
          (car front-ptr)))

    (define (insert-queue! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-queue?)
               (set-front-ptr! new-pair)
               (set-rear-ptr! new-pair)
               front-ptr)
              (else
               (set-cdr! rear-ptr new-pair)
               (set-rear-ptr! new-pair)
               front-ptr))))

    (define (delete-queue!)
      (cond ((empty-queue?)
             (error "DELETE! called with an empty queue"))
            (else
             (set-front-ptr! (cdr front-ptr))
             front-ptr)))
    
    (define (dispatch m)
      (cond ((eq? m 'empty-queue?) (empty-queue?))
            ((eq? m 'front-queue) (front-queue))
            ((eq? m 'insert-queue!) insert-queue!)
            ((eq? m 'delete-queue!) (delete-queue!))
            (else (error "Invalid operation: " m))))
    dispatch))

(define (insert-queue! queue elem)
  ((queue 'insert-queue!) elem))

(define (empty-queue? queue)
  (queue 'empty-queue?))

(define (front-queue queue)
  (queue 'front-queue))

(define (delete-queue! queue)
  (queue 'delete-queue!))
{% endhighlight %}

--------

And now we can test the code (Adding As = 1 1 1 and Bs =  1 1 1 results Ss = 110 and C = 1):

{% highlight scheme linenos %}
1 ]=> (define x1 (make-wire))

;Value: x1

1 ]=> (define x2 (make-wire))

;Value: x2

1 ]=> (define x3 (make-wire))

;Value: x3

1 ]=> (define y1 (make-wire))

;Value: y1

1 ]=> (define y2 (make-wire))

;Value: y2

1 ]=> (define y3 (make-wire))

;Value: y3

1 ]=> (define s1 (make-wire))

;Value: s1

1 ]=> (define s2 (make-wire))

;Value: s2

1 ]=> (define s3 (make-wire))

;Value: s3

1 ]=> (define CC (make-wire))

;Value: cc

1 ]=> (set-signal! x1 1)

;Value: done

1 ]=> (set-signal! x2 1)

;Value: done

1 ]=> (set-signal! x3 1)

;Value: done

1 ]=> (set-signal! y1 1)

;Value: done

1 ]=> (set-signal! y2 1)

;Value: done

1 ]=> (set-signal! y3 1)

;Value: done

1 ]=> (ripple-carry-adder (list x1 x2 x3) (list y1 y2 y3) (list s1 s2 s3) CC)

;Value: ok

1 ]=> (propagate)

;Value: done

1 ]=> (get-signal s1)

;Value: 1

1 ]=> (get-signal s2)

;Value: 1

1 ]=> (get-signal s3)

;Value: 0

1 ]=> (get-signal CC)

;Value: 1

1 ]=> 

{% endhighlight %}
